const core = require(`@actions/core`);
const github = require(`@actions/github`);
const azdev = require(`azure-devops-node-api`);

// create Work Item via https://docs.microsoft.com/en-us/rest/api/azure/devops/
async function createIssue(token, orgUrl, projectName, title, description) {
  let authHandler = azdev.getPersonalAccessTokenHandler(token); 
  let connection = new azdev.WebApi(orgUrl, authHandler);
  let workapi = await connection.getWorkItemTrackingApi();
  return workapi.createWorkItem(
    customHeaders = [],
    document = [
      { 'op': 'add', 'path': '/fields/System.Title', 'value': title },
      { 'op': 'add', 'path': '/fields/System.Description', 'value': description },
    ],
    project = projectName,
    type = `Issue`
    )
}

// get alert data from https://developer.github.com/v4/object/repositoryvulnerabilityalert/
async function getVulnerabilities(context) {
  let octokit = new github.GitHub(process.env.GITHUB_TOKEN);
  let query = `
  query {
    repository(owner:"${context.payload.repository.owner.login}",name:"${context.payload.repository.name}") {
      vulnerabilityAlerts(first:100) {
        totalCount,
        nodes {
          securityVulnerability {
            advisory {
              description
              identifiers {
                type
                value
              }
              references {
                url
              }
              severity
              summary
            }
            firstPatchedVersion {
              identifier
            }
            package {
              name
              ecosystem
            }
            severity
            updatedAt
            vulnerableVersionRange
          }
          repository {
            nameWithOwner
          }
          vulnerableManifestFilename
          vulnerableManifestPath
          vulnerableRequirements
        }
      }
    }
  }
  `
  return await octokit.graphql(query, {headers: {authorization: `token ${process.env.GITHUB_TOKEN}`}});
}

try {
  console.log(`Running`);
  core.setOutput(`id`, (new Date()).toTimeString()); //TBD: actual Work Item ID
  let context = github.context
  if(context.eventName==`pull_request` && context.actor==`dependabot[bot]` && context.payload.pull_request.title.startsWith(`Bump `)) {
    let [ ,dep_name, ,version_from, , version_to] = context.payload.pull_request.title.split(` `);
    console.log(`Searching for Vulnerability Alerts with package name "${dep_name}" to patch to "${version_to}"`);
    getVulnerabilities(context).then(vulnerabilities => {
      let vulnerability = undefined;
      vulnerabilities.repository.vulnerabilityAlerts.nodes.forEach(n => {
        console.log(`Found package name "${n.securityVulnerability.package.name}" to patch to "${n.securityVulnerability.firstPatchedVersion.identifier}"`);
        if(n.securityVulnerability.package.name==dep_name && n.securityVulnerability.firstPatchedVersion.identifier==version_to) {
          vulnerability = n.securityVulnerability;
        }
      });
      if(vulnerability) {
        console.log(`Creating issue with...
        Title: ${context.payload.pull_request.title}
        Severity: ${vulnerability.severity}
        Description: ${html_url}\n${vulnerability.advisory.description}
        `);
        createIssue(
          process.env.AZURE_PERSONAL_ACCESS_TOKEN,
          process.env.ORG_URL,
          process.env.PROJECT_NAME,
          context.payload.pull_request.title,
          `${html_url}\n${vulnerability.advisory.description}`
          ).then(result => {
          console.log(result)
        }).catch(error => {
          core.setFailed(error.message);
        });
      } else {
        console.log(`No matching vulnerabilities found:
        ${JSON.stringify(vulnerabilities,undefined,2)}
        `)
      }
    }).catch(error => {
      core.setFailed(error.message);
    });
  } else {
    console.log(`This is not a Pull Request generated by Dependabot...
    Event: ${context.eventName}
    Actor: ${context.actor}
    Title: ${context.payload.pull_request.title}
    `)
  }
} catch (error) {
  core.setFailed(error.message);
}